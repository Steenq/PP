Вариант 1
Первая группа вопросов:
1)Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
Инкапсуляция тут в том, что фабрика прячет от нас, как именно создаются объекты. Мы просто знаем, что у нас есть, например, мебельная фабрика, которая умеет делать стулья и столы,
но не вникаем, как именно эти стулья собираются.
Задачи, которые решает:
- Нужна согласованность между продуктами, например, если стул современный, то и стол из той же серии, а не случайный.
- Удобно, когда требуется легко заменять одну "фабрику" на другую, не переписывая основной код.

Пример:
У вас есть программа, которая создаёт интерфейсы для разных операционных систем (Windows, macOS). Абстрактная фабрика помогает создать кнопки и меню, подходящие к одной ОС.
Практически это используется в графических интерфейсах, играх (например, разные текстуры для объектов на разных уровнях), в конфигурируемых системах, где легко переключаться между "настройками" под разные сценарии.

2)Закон Деметры (не знаешь больше, чем нужно). Класс не должен общаться с чужими объектами напрямую, только с "соседями".
Закон минимизации сложности: каждая часть системы должна быть максимально простой в использовании.

Вторая группа вопросов:
1)ООП декомпозиция - это когда вы разбиваете проблему на части через классы и объекты. Например, если вы разрабатываете игру, то разбиваете всё на: Игрок, Враг, Уровень. Каждый объект решает свою задачу. 
Декомпозиция нужна, чтобы не было "свалки" кода – всё логично распределено и читабельно.
2)Полиморфизм – это когда у нас одна "форма", но работает по-разному. Статический – это в compile-time, то есть ещё до выполнения программы. Пример: метод с одним именем, но разными аргументами
(method(int x) и method(String s)). Это перегрузка метода.
3)Инкапсуляция - это когда скрываем то, как работает программа под капотом. В коде это означает, что данные скрываются через private, а наружу показываются только через public методы. 
Инкапсуляция нужна, чтобы защитить данные и избежать путаницы.
Пример:
class Car {
    private Engine engine;

    public void start() {
        engine.start();
    }
}
Снаружи вы просто вызываете start(), не вникая, как именно мотор заводится.
